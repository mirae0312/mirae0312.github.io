<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>class</title>
</head>
<body>
  <h1>class</h1>
  <button onclick="test1();">실행</button>
  <script>
  // Book .class로 만들기
  const test2 = () => {
    const books = [
      new Book("매트릭스", 35000, 0.15),
      new Book("오라클", 30000, 0.2),
      new Book("네오의 하루", 20000),
      new Book("So Smith~", 15000, 0.3),
    ];
    console.log(books);

    books.forEach((book, i) => {
      console.log(book.getSalePrice());
      console.log(book.toString()); // 매트릭스 가격:29750원(정가: 35000원)
      // console.log(book.getAd());
    });

  };

  class Ad{
    getAd(){
      return `화제의 신간 [${this.title}]이 출간되었습니다.`;
    }
  }

  class Book extends Ad {
    constructor(title, price, discountRate){
      super();
      this.title = title;
      this.price = price;
      this.discountRate = discountRate;
    }
    
    toString(){
      return `${this.title} 가격: ${this.getSalePrice()}원(정가: ${this.price}원)`;
    };

    getSalePrice(){
      return this.discountRate ? this.price - (this.price * this.discountRate) : this.price;
    };
  }

  const test1 = () => {
    const user = new User('honggd', '홍길동', 33);
    console.log(user);
    user.info();
    user.run();

    console.log(User, typeof User);
  };

  class Runner {
    run(){
      console.log(`${this.name}이 달린다.`);
    }
  }

  /**
   * 생성자함수의 syntatic sugar 문법설탕
   *  - 동일한 이름의 생성자함수를 생성
   *  - 반드시 new연산자로 호출 
   *  - this로 현재객체에 속성을 등록가능
   *  - method는 prototype객체에 자동등록
   */
  class User extends Runner {
    /**
     * new연산자 호출 메소드
     */ 
    constructor(id, name, age){
      super(); // 상속시에는 부모생성자를 명시적으로 호출(안하면 오류)
      this.id = id;
      this.name = name;
      this.age = age;
    }

    /**
     * 메소드
     */
    info(){
      console.log(`${this.id} : ${this.name}(${this.age})`);
    }


  }
  </script>
</body>
</html>